# Микро и макро архитектура
## Введение
С одной стороны архитектура приложения должна помогать микросервисам работать вместе, с другой она не должна связывать их слишком сильно, чтобы не убить все преимущество использования микросервисов.

Уместно будет разделить архитектуру микросервисов на микро и макро уровень:
- Микроархитектура отвечает за все решения относительно отдельного микросервиса
- Макроархитектура отвечает за все решения принимаемые на глобальном уровне применимом ко всем составляющим системы

## DDD & Связанные контексты
Макроархитектура отвечает за разделение предметной области на крупные модули, которые дальше делятся на еще более мелкие части микроархитектурой.

К примеру интернет магазин можно разделить на следующие модули и субмодули:
- Регистрация пользователей
- Обработка заказов
	- Валидация данных
	- Вычисление стоимости
- Оплата
- Доставка

Внутрення архитектура обработки заказов скрыта от внешнего наблюдателя и может быть измененена без влияния на остальные части приложения. Подобная гибкость является одним из главных преимуществ микросервисной архитектуры.

Данные требуемые отдельным модулям для функционирования различаются не только по составу, но и по своей сути. К примеру модулям доставки и оплаты требуются данные пользователя, но их требования к наполнению эти данных различны.

## Предметно ориентированный дизайн
DDD предлагает набор паттернов для создания предметно ориентированной модели системы. Оно описывает каким образом все приложение может быть разделено на связанные контексты.

Каждая домене модель актуальна только в своем контексте. Таким образом макро-модули из верхнего списка являются связанными контекстами предметной модели интернет магазина.

Для обмена данными между контекстами можно использовать события предметной области (domain events). События являются частью предметной области, так как они описывают что-то происходящее в ней.

К примеру подтверждение заказа в корзине является событием этой предметной области. Контекст обработки и доставки заказа реагирует на это событие и инициализирует соответствующие процессы в этих контекстах.

Связанные контексты описывают разделение системы на домены, но они не обязаны быть отдельными микросервисами. Они так же могут быть реализованы в качестве модулей монолитного приложения.

Макроархитектура не обязана быть статичной:
- Новая фунуциональность может потребовать выделения новых контекстов
- Существующие контексты могут быть разделены
- Отдельные микросервисы могут делиться в связи с технической необходимостью (масштабировать эти части приложения по отдельности)

## Стратегический дизайн и общие паттерны
Разделение системы на различные связанные контексты - это часть стратегического дизайна, который является общей практивной DDD. Стратегический дизайн описывает интеграцию связанных контекстов.

![[Pasted image 20220424161258.png]]

- Связанный контекст - это контекст в котором доменная модель имеет значение и валидна.
- Контексты зависят друг от друга. Обычно отдельный контекст разрабатывает отдельная команда.
- Работа команда upstream констекста влияет на работу команды downstream контекста, обратной связи нет.

DDD описывает несколько паттернов того каким именно образом происходит взаимодействие между контекстами.

## Паттерн "поставщик - потребитель"
В этом взаимодействии поставщик - это upstream контекст, а потребитель - downstream. Хотя оплата заказа определяет требования для процесса обработки заказа, оплата может быть совершена только если контекст обработки заказа предоставит необходимые данные. Таким образом контекст оплаты становится потребителем контекста обработки заказов и может предъявить ему свои требования.

![[Pasted image 20220424162156.png]]

## Паттерн "конформист"
Конформист означает, что один связанный конекст просто использует доменную модель из другого контекста.

В примере ниже контексты статистики и обработки заказов используют одну и ту же доменную модель. Статистика использует модель заказа из другого контекста, выдергивает из нее нужные именно для статистики данные и складывает их в хранилище. 

В то же время контекст статистики не может ничего предъявить контексту обработки заказов, если тот вдруг решит поменять модель. Также контекст статистики не может требовать получения каких-либо дополнительных данных от контекста обработки заказов (если конечно они сами не захотят предоставить эти данные).

![[Pasted image 20220424162620.png]]

## Паттерн "Предохранительный слой" (ACL)
Предохранительный слой похож на паттерн Конформист, однако, в этом паттерне, downstream контекст не использует напрямую доменную модель другого контекста, но использует для этого предохранительный слой чтобы развязать реализацию модели в другом контексте от своей.

В примере ниже контекст Доставка использует предохранительный слой для связи с контекстом устаревшего кода (Legacy). Это обеспечивает независимость модели контекста доставки.

![[Pasted image 20220424163154.png]]

## Паттерн "разные пути" (separate ways)
В данном паттерне контексты не связанны напрямую, однако на уровне ПО взаимодействие все же может происходить.

Например, добавляется новый контекст Оплата. Он может собирать данные для отображения продуктов, но реализован отдельно от него. Контекст оплаты будет отделен от остальной системы. Оплата инициирует процессы в контексте доставки, который в свою очередь тригерит процессы добавления товара в список приобретенных ранее в другом контексте.

Оплата -> Отправка -> Доставка -> Список приобретенных товаров.

Таким образом контект оплаты напрямую не зависит от контекста приобретенных товаров и может быть реализован отдельно.

## Паттерн "Разделяемое ядро"
Разделяемое ядро описывается общую часть, используемую несколькими контекстами. Общие данные покупателя являютя примером такого взаимодействия.

Паттерн Разделяемое ядро предполагает общую кодовую базу и общую базу данных, так что он не должен использоваться в микросервисной архитектуре. Для микросервисов это антипаттерн, но для монолитов может быть норм.

В примере ниже Обработка заказа и Оплата используют разделяемое ядро.
![[Pasted image 20220424164551.png]]

Некоторые паттерны удобны, когда необходимо описать взаимодействие сразу нескольких контекстов.

## Паттерн "Общедоступный сервис"
Общедоступный сервис подразумевает, что какой-то из контекстов публикует унифицированный интерфейс с несколькими предоставляемыми сервисами. Другие контексты могут реализовывать свои собственные пути интеграции с этим контекстом. Примером такого паттерна являются различные публичные API.

## Паттерн "Публичная модель"
Публичный язык - это доменная модель доступная для любых связанных контекстов. Это может быть как общепринятый стандарт, так и приватная структура для обмена данными внутри компании.

Публичная модель может использоваться совместно с Общедоступным сервисом. Например контекст Заказа может принимать заказы от внешних клиентов предоставляя Общедоступный сервис и Публичную модель. В этом случае делать отдельные сервисы и модели для каждого конкретного клиента было бы слишком затратно.

![[Pasted image 20220424165328.png]]

## Выбор паттерна взаимодействия
Выбор паттерна взаимодействия должен основываться на:
- Предметной области
- Бизнес процессах
- Коммуникации между командами

Например, если контекст оплаты не получит необходимые данные от контекста обработы заказов, он не сможет провести оплату. Таким образом паттерн "Поставщик/Потребитель" будет тут очевидным выбором. В то же время этот выбор вытекает не из предметной области как таковой, а именно из бизнес процессов компании.

Выбранный паттерн создает необходимость координации разработки между командами реализующими разные контексты и снижает независимость сервисов, так что использовать его нужно только при явной необходимости.

## Архитектурные решения
Микросервисы предоставляют технологическую изоляцию, поэтому возможно расширить концепты микро и макро архитектуры на применяемые технические решения.

Для монолитов такое разделение не имеет смысла, т.к. любые решения применяются по сути глобально.

## Языки программирования, фреймворки, инфраструктура
Языки программирования, фреймворки и инфраструктура могут определяться для каждого микросервиса индивидуально на микро урове.
- Каждый микросервис может использовать свой язык программирования
- Технология типа сервера приложений, которая наилучшим образом подходит для этого сервиса так же может быть выбрана в рамках отдельного микросервиса.

Тоже самое может быть определено для всех микросервисов сразу на макроуровне, если:
 - Стек применяемых технологий определяется компанией разработчиком, так что большого разнообразия тут не наблюдается.

## Базы данных
Тут вроде бы тоже самое, что с языками программирования, но стоит учесть, что БД хранят данные и терять их не хочется. Так что на макро уровне должны быть определены протоколы резервного копирования восстановления данных.

Каждый сервис может (и должен) иметь свою собственную базу данных. Так что БД определяется на микро уровне.
- Если БД упадет, это повличет падение микросервиса, но система в целом продолжит работать
- В то же время обеспечение резервного копирования для каждой отдельной БД может быть накладным.

Чтобы избежать зоопарка технологий, можно попределить доступные БД на макро уровне. При этом нужно следить, чтобы каждый микросервис использовал свой изолированный от других инстанс БД, чтобы не создавать излишней связанности.

## Пользовательский интерфейс
Если у микросервиса есть свой собственный UI, его вид и свойства могут быть определены как на микро, так и на макро уровне.

Если сервисы обслуживают разные типы пользователей (например основная часть сайта и бэкофис), их UI может сильно отличаться и определяться на микроуровне.

В то же время микросервисы, являющиеся частью единой системы, должны иметь унифицированный интерфейс. Его можно определить на макро уровне.

В этом случае нужно создать руководство по стилю (style guide), которому должны будут следовать различные сервисы.

## Документация
Конечно же на микро уровне сервиса нужна своя документация, которая описывает данный конкретный микросервис, в то же время она может быть стандартизирована на макро уровне и на макро уровне описывать состав и взаимодействие микросервисов в системе.

## Типичные макро архитектурные решения
- Протоколы коммуникации и стандартны передачи данных.
- Механизмы идентификации.
- Механизмы интеграционного тестирования.

## Типичные микро архитектурные решения
- Механизмы аутентификации. Определение того, что пользователю разрешено делать определяется логикой конкретного микросервиса и таким образом является часть микро архитектуры.
- Тестирование. Состав и объем тестового покрытия может сильно различаться от сервиса к сервису.

Итого:

![[Pasted image 20220424212246.png]]

# Функционирование приложений: микро или макро уровнень?

