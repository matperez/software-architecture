# Микро и макро архитектура
## Введение
С одной стороны архитектура приложения должна помогать микросервисам работать вместе, с другой она не должна связывать их слишком сильно, чтобы не убить все преимущество использования микросервисов.

Уместно будет разделить архитектуру микросервисов на микро и макро уровень:
- Микроархитектура отвечает за все решения относительно отдельного микросервиса
- Макроархитектура отвечает за все решения принимаемые на глобальном уровне применимом ко всем составляющим системы

## DDD & Связанные контексты
Макроархитектура отвечает за разделение предметной области на крупные модули, которые дальше делятся на еще более мелкие части микроархитектурой.

К примеру интернет магазин можно разделить на следующие модули и субмодули:
- Регистрация пользователей
- Обработка заказов
	- Валидация данных
	- Вычисление стоимости
- Оплата
- Доставка

Внутрення архитектура обработки заказов скрыта от внешнего наблюдателя и может быть измененена без влияния на остальные части приложения. Подобная гибкость является одним из главных преимуществ микросервисной архитектуры.

Данные требуемые отдельным модулям для функционирования различаются не только по составу, но и по своей сути. К примеру модулям доставки и оплаты требуются данные пользователя, но их требования к наполнению эти данных различны.

## Предметно ориентированный дизайн
DDD предлагает набор паттернов для создания предметно ориентированной модели системы. Оно описывает каким образом все приложение может быть разделено на связанные контексты.

Каждая домене модель актуальна только в своем контексте. Таким образом макро-модули из верхнего списка являются связанными контекстами предметной модели интернет магазина.

Для обмена данными между контекстами можно использовать события предметной области (domain events). События являются частью предметной области, так как они описывают что-то происходящее в ней.

К примеру подтверждение заказа в корзине является событием этой предметной области. Контекст обработки и доставки заказа реагирует на это событие и инициализирует соответствующие процессы в этих контекстах.

Связанные контексты описывают разделение системы на домены, но они не обязаны быть отдельными микросервисами. Они так же могут быть реализованы в качестве модулей монолитного приложения.

Макроархитектура не обязана быть статичной:
- Новая фунуциональность может потребовать выделения новых контекстов
- Существующие контексты могут быть разделены
- Отдельные микросервисы могут делиться в связи с технической необходимостью (масштабировать эти части приложения по отдельности)

## Стратегический дизайн и общие паттерны
Разделение системы на различные связанные контексты - это часть стратегического дизайна, который является общей практивной DDD. Стратегический дизайн описывает интеграцию связанных контекстов.

![](attachments/Pasted%20image%2020220424161258.png)

- Связанный контекст - это контекст в котором доменная модель имеет значение и валидна.
- Контексты зависят друг от друга. Обычно отдельный контекст разрабатывает отдельная команда.
- Работа команда upstream констекста влияет на работу команды downstream контекста, обратной связи нет.

DDD описывает несколько паттернов того каким именно образом происходит взаимодействие между контекстами.

## Паттерн "поставщик - потребитель"
В этом взаимодействии поставщик - это upstream контекст, а потребитель - downstream. Хотя оплата заказа определяет требования для процесса обработки заказа, оплата может быть совершена только если контекст обработки заказа предоставит необходимые данные. Таким образом контекст оплаты становится потребителем контекста обработки заказов и может предъявить ему свои требования.

![](attachments/Pasted%20image%2020220424162156.png)

## Паттерн "конформист"
Конформист означает, что один связанный конекст просто использует доменную модель из другого контекста.

В примере ниже контексты статистики и обработки заказов используют одну и ту же доменную модель. Статистика использует модель заказа из другого контекста, выдергивает из нее нужные именно для статистики данные и складывает их в хранилище. 

В то же время контекст статистики не может ничего предъявить контексту обработки заказов, если тот вдруг решит поменять модель. Также контекст статистики не может требовать получения каких-либо дополнительных данных от контекста обработки заказов (если конечно они сами не захотят предоставить эти данные).

![](attachments/Pasted%20image%2020220424162620.png)

## Паттерн "Предохранительный слой" (ACL)
Предохранительный слой похож на паттерн Конформист, однако, в этом паттерне, downstream контекст не использует напрямую доменную модель другого контекста, но использует для этого предохранительный слой чтобы развязать реализацию модели в другом контексте от своей.

В примере ниже контекст Доставка использует предохранительный слой для связи с контекстом устаревшего кода (Legacy). Это обеспечивает независимость модели контекста доставки.

![](attachments/Pasted%20image%2020220424163154.png)

## Паттерн "разные пути" (separate ways)
В данном паттерне контексты не связанны напрямую, однако на уровне ПО взаимодействие все же может происходить.

Например, добавляется новый контекст Оплата. Он может собирать данные для отображения продуктов, но реализован отдельно от него. Контекст оплаты будет отделен от остальной системы. Оплата инициирует процессы в контексте доставки, который в свою очередь тригерит процессы добавления товара в список приобретенных ранее в другом контексте.

Оплата -> Отправка -> Доставка -> Список приобретенных товаров.

Таким образом контект оплаты напрямую не зависит от контекста приобретенных товаров и может быть реализован отдельно.

## Паттерн "Разделяемое ядро"
Разделяемое ядро описывается общую часть, используемую несколькими контекстами. Общие данные покупателя являютя примером такого взаимодействия.

Паттерн Разделяемое ядро предполагает общую кодовую базу и общую базу данных, так что он не должен использоваться в микросервисной архитектуре. Для микросервисов это антипаттерн, но для монолитов может быть норм.

В примере ниже Обработка заказа и Оплата используют разделяемое ядро.
![](attachments/Pasted%20image%2020220424164551.png)

Некоторые паттерны удобны, когда необходимо описать взаимодействие сразу нескольких контекстов.

## Паттерн "Общедоступный сервис"
Общедоступный сервис подразумевает, что какой-то из контекстов публикует унифицированный интерфейс с несколькими предоставляемыми сервисами. Другие контексты могут реализовывать свои собственные пути интеграции с этим контекстом. Примером такого паттерна являются различные публичные API.

## Паттерн "Публичная модель"
Публичный язык - это доменная модель доступная для любых связанных контекстов. Это может быть как общепринятый стандарт, так и приватная структура для обмена данными внутри компании.

Публичная модель может использоваться совместно с Общедоступным сервисом. Например контекст Заказа может принимать заказы от внешних клиентов предоставляя Общедоступный сервис и Публичную модель. В этом случае делать отдельные сервисы и модели для каждого конкретного клиента было бы слишком затратно.

![](attachments/Pasted%20image%2020220424165328.png)

## Выбор паттерна взаимодействия
Выбор паттерна взаимодействия должен основываться на:
- Предметной области
- Бизнес процессах
- Коммуникации между командами

Например, если контекст оплаты не получит необходимые данные от контекста обработы заказов, он не сможет провести оплату. Таким образом паттерн "Поставщик/Потребитель" будет тут очевидным выбором. В то же время этот выбор вытекает не из предметной области как таковой, а именно из бизнес процессов компании.

Выбранный паттерн создает необходимость координации разработки между командами реализующими разные контексты и снижает независимость сервисов, так что использовать его нужно только при явной необходимости.

## Архитектурные решения
Микросервисы предоставляют технологическую изоляцию, поэтому возможно расширить концепты микро и макро архитектуры на применяемые технические решения.

Для монолитов такое разделение не имеет смысла, т.к. любые решения применяются по сути глобально.

## Языки программирования, фреймворки, инфраструктура
Языки программирования, фреймворки и инфраструктура могут определяться для каждого микросервиса индивидуально на микро урове.
- Каждый микросервис может использовать свой язык программирования
- Технология типа сервера приложений, которая наилучшим образом подходит для этого сервиса так же может быть выбрана в рамках отдельного микросервиса.

Тоже самое может быть определено для всех микросервисов сразу на макроуровне, если:
 - Стек применяемых технологий определяется компанией разработчиком, так что большого разнообразия тут не наблюдается.

## Базы данных
Тут вроде бы тоже самое, что с языками программирования, но стоит учесть, что БД хранят данные и терять их не хочется. Так что на макро уровне должны быть определены протоколы резервного копирования восстановления данных.

Каждый сервис может (и должен) иметь свою собственную базу данных. Так что БД определяется на микро уровне.
- Если БД упадет, это повличет падение микросервиса, но система в целом продолжит работать
- В то же время обеспечение резервного копирования для каждой отдельной БД может быть накладным.

Чтобы избежать зоопарка технологий, можно попределить доступные БД на макро уровне. При этом нужно следить, чтобы каждый микросервис использовал свой изолированный от других инстанс БД, чтобы не создавать излишней связанности.

## Пользовательский интерфейс
Если у микросервиса есть свой собственный UI, его вид и свойства могут быть определены как на микро, так и на макро уровне.

Если сервисы обслуживают разные типы пользователей (например основная часть сайта и бэкофис), их UI может сильно отличаться и определяться на микроуровне.

В то же время микросервисы, являющиеся частью единой системы, должны иметь унифицированный интерфейс. Его можно определить на макро уровне.

В этом случае нужно создать руководство по стилю (style guide), которому должны будут следовать различные сервисы.

## Документация
Конечно же на микро уровне сервиса нужна своя документация, которая описывает данный конкретный микросервис, в то же время она может быть стандартизирована на макро уровне и на макро уровне описывать состав и взаимодействие микросервисов в системе.

## Типичные макро архитектурные решения
- Протоколы коммуникации и стандартны передачи данных.
- Механизмы идентификации.
- Механизмы интеграционного тестирования.

## Типичные микро архитектурные решения
- Механизмы аутентификации. Определение того, что пользователю разрешено делать определяется логикой конкретного микросервиса и таким образом является часть микро архитектуры.
- Тестирование. Состав и объем тестового покрытия может сильно различаться от сервиса к сервису.

Итого:

![](attachments/Pasted%20image%2020220424212246.png)

# Функционирование приложений: микро или макро уровнень?
## Конфигурация
Мы должны определить интерфейс через который микросервис получает параметры конфигурации. Например он может делать это через переменные окружения или читать настройки из файла. Эти параметры могут включать как технические настройки типа размера пула соединений, так и параметры доменной логики.

Решение о том как хранить настройки или генерировать их уже не зависит от того как сервис их получает.

Для передачи паролей и сертификатов удобно использовать стороние инструменты типа Vault.

## Мониторинг
На макроуровне определяется технология для сбора метрик. Какие именно метрики собирать зависит уже от микроуровня.

## Логирование
На макроуровне необходимо выбрать какое-то решение для сбора и нализа логов. Чаще всего для этого выбирают специализированные инструменты. Логи нужно хранить и с тех сервисов, который уже выключены.

## Деплой
Технологии деплоймента определяют каким образом микросервис выкатывается в продакшн. Чаще всего такой выбор является частью как микро, так и макро архитектуры.

Например команда разработала микросервис и отдала его команде эксплуатации. Тогда деплой является макроархитектурным решением. Если же команда разработки так же отвечает и за эксплуатацию сервиса, такие решения могут приниматься и на микроуровне.

## Тестирование макроархитектуры на конкретном сервисе
Тесты могут выявлять соответствие конкретного микросервиса заданной макроархитектуре. Например то, что при сбоях он предоставляет все необходимые логи и метрики для выяснения причин возникшего сбоя.

Итого, решения об эксплуатации может приниматься как на микро (когда команда разработки сама отвечает за эксплуатацию сервиса), так и на макроуровне (когда есть отдельная команда эксплуатации).

![](attachments/Pasted%20image%2020220425004046.png)

# Приоритет микроархитектуры
Есть определенные причины принимать максимальное число решенией на микро уровне. Давайте их обсудим.

## Макроархитектурные решения: лучшие практики и советы
- Не старайтесь определить все на макро уровне. В сложных, больших проектах это сложно сделать. Чем меньше решений принято на макро уровне, тем больше вероятность, что они все будут реализованы.
- Сами правила должны быть минимальны. Например можно определить технологию сбора метрик, но не нужно пытаться ограничивать какие именно метрики будут собираться.
- Принятые решения нужно обязательно исполнять. Например если принято решение собирать метрики, сервис, который их не предоставляет вообще не должен допускаться до продакшена.
- Независимость - важное преимущество микросервисов. Слишком подробные требования со стороны макроархитектуры могут привести к излишней связности.
- Соблюдение требований макроархитектуры должно соответствовать интересам отдельных команд.

В дополнению к строгим правилам макроархитектуры можно вводить рекомендации и практики опциональные для исполнения.

## Эволюция макроархитектуры
Макроархитектура может меняться в процессе развития проекта. К примеру вначале можно строго ограничить язык программирования, но в процессе развития добавить возможность использования и других языков или библиотек, если их использование будет обосновано.

# Организационные нюансы
Ответственность за принимаемые решения должны нести те, кто их принимает. К примеру, если инструмент для сбора метрик утвержден на макро-уровне, отдельная команда не должна нести ответственность, что для их конкретного микросервиса этот инструмент не подходи.

## Неконтролируемый рост
Свобода выбора может привести к неконтролируемому росту числа используемых технологий, но это не обязательно случится. Если команды обменимаются лучшими практиками, они скорее всего договорятся об использовании одной какой-то технологии между всеми сервисами, для этого они, конечно должны активно общаться и обмениваться знаниями.

## Кто должен определять макроархитектуру?
### Комитет представителей
Макроархитектура ограничивает свободу команд. Чтобы это было не сильно больно, можно создавать комитеты в которые должны входить представители от каждой команды. Если команд много, комитет может стать слишком большим и неэффективным. В этом случае можно часть команд исключить из комитета или брать одного представителя сразу на несколько команд. 

К сожалению часто бывает так, что представители команд сликом сфокусированы на своем мироксервисе, чтобы интересоваться глобальной картиной.

### Независимый архитектурный комитет
Альтернативой комитету представителей является комитет независимых экспертов не принадлежащих ни одной из команд.
- Целью комитета должна быть поддержка команд и урегулирование решений, а не силовое их внедрение. Взаимодействие с командами может быть улучшено, если члены комитета принимают хоть какое-то участие в жизни команд.
- Члены комитеты должны быть интегрированы и заинтересованы в разработке конечного продукта.
- Нельзя забывать и забивать на доменные и бизнес требования

## Как внедрять требования?
Макроархитектурные решения должны приниматься и пониматься командами, так что команда, которая их принимает должна подробно описывать причины их принятия.

Нужно упирать не на силвое их внедренеие а на популяризацию.

## Тестирование соответствия
В некоторых случаях можно явно протестировать соответствие микросервиса принятым макроархитектурным решениям просто залив его на прод и проверив логи и метрики. Такие тесты называются тестированием черного ящика. Плюсы такого подхода в том, что он не ограничивает используемые технологии и позволяет держать правила достаточно общими, не вдавающимися в подробности.

# Принципы архитектуры независимых систем (Independent Systems Architecture)
ISA опредляет термины микро и макро ахритектуры, а так же принципы, объясняющие каковы должны быть минимальные требования к ним.

## Условия
Условия могут быть двух типов: должен и желательно. Т.е. отдельные правила из списка ниже могут примеяться либо обязательно, либо им неплохо бы следовать.

## Принцип 1: система должна быть разделена на модули
Система должна быть разделена на модули предлагающие интерфейсы. Взаимодействие с этими модулями возможно только через предоставляемые интерфейсы.Модули не должны зависеть от внутренних деталей реализации друг-друга типа модели данных в БД.
![](attachments/Pasted%20image%2020220425015556.png)

## Принцип 2: два разных уровня архитектурных решений
Система должна иметь два разных уровня архитектурных решений:
- Макро архитектура определяет решения применяемые ко всем модулям.
- Микро архитектура определяет решения принимаемые относительно отдельных модулей.
![](attachments/Pasted%20image%2020220425015741.png)

## Принцип 3: Модули должны работать в изолированных процессах, контейнерах, виртуальных машинах
Модули должны работать в изолированных процессах, контейнерах, виртуальных машинах для максимальной независимости.
![](attachments/Pasted%20image%2020220425015946.png)

## Принцип 4: Cтандарты интеграции и коммуникации
Выбор технологии для интеграции и коммуникации должен быть ограничени и стандиртизован на уровне всей системы.

Без единого подхода к интеграции и единой технологии для коммуникации сложно рассматривать систему как систему, а не просто несколько отдельных сервисов, которые как-то там между собой взаимодействуют.

## Принцип 5: Стандартизация метаданных
Метаданные необходимые к примеру для аутентификации должны быть стандартизированы. Иначе пользователям придется индентифицировать себя для каждого сервиса по отдельности. Это может быть реализовано, к примеру, с помощью токена добавляемого к каждому запросу/вызову.

Тоже самое касается формата трассировки вызовов. 

Трассировка и аутентификация обычно должны быть сквозной функциональностью среди всех сервисов системы.

## Принцип 6: Независимые конвейеры непрерывной доставки
Каждый модуль должен иметь свой независмый процесс ci/cd. Тесты тоже должны быть независимыми.
![](attachments/Pasted%20image%2020220425021435.png)

## Принцип 7: Эксплуатацию неплохо бы стандартизировать
Эксплуатацию неплохо бы стандартизировать, однако тут могут быть исключения в виду специфических требований отдельных сервисов. Эксплуатация включает в себя:
- Конфигурирование
- Деплой
- Анализ логов
- Трассировку
- Мониторинг
- Оповещения

Такая стандартизация позволяет вменяемым образом обслуживать большое число различных микросервисов.

## Принцип 8: Стандартный интерфейс
Стандарты эксплуатации, интеграции и коммуникации неплохо бы внедрять на уровне интерфейсов.

К примеру протокол коммуникации и структуры данных могут быть заданы определенным форматом JSON сообщений через протокол HTTP, однако отдельные сервисы могут отстпать от этого правила.

## Принцип 9: Модули должны быть устойчивыми
Модули должны быть устойчивыми. Это означает, что:
- Они не должы падать, когда падают другие модули или возникает ошибка коммуникации
- Они должны уметь выключатья без потери данных или состояния
- Должна быть возможность переносить модули в другое окружение без падения этого модуля.

Асинхронные коммуникации позволяют делать модули устойчивыми к сбоям. Если сервис упадет или будет перенесен в другое окружение, исходное сообщение все равно до него дойдет.

# Отступление от правил
Необходимость использования макроархитектуры, стратегического дизайна и доменно-ориентированного дизайна невозможно подвергать сомнению. Однако разделение на связанные контексты зависит от конкретного проекта и архитектора. Техническая микро и макроархитектура так же может различаться между проектами. Это все зависит от следующих факторов:
- Организационные нюансы. Типа того, есть ли отдельная devOps команда в компании.
- Стратегические решения отностительно применяемых технологий.
- Даже политика найма персонала может иметь значение.

Некоторые правила невозможно отнести только к микро или только к макро архитектуре. К примеру белый список доступных языков программирования на задается на макроуровне, но оставляет командам решать на микроуровне какой именно язык использовать.

### Упражнение
Возьмите проект, с которым вы хорошо знакомы. Посмотрите на его предметную область и ответьте на следующие вопросы:
- Сделает ли разделение модели на несколько связанных конекстов ее понятнее?
- Сколько нужно связанных контекстов? Обычно их около десятка, но все зависит от конкретного проекта.
- Определите примеры использования системы. Сгруппируйте примеры использования и проверьте могут ли они быть реализованы предметной моделью. Таким образом вы сформируете связанные котексты в которых доменная модель будет актуальной.
- Подумайте нужно ли еще больше разделить контексты в связи с техническими требованиями типа безопасности или масштабирования

Определитесь должны ли отдельные решения быть часть микро или макроархитектуры?
