# Миграция
Миграция из монолита в микросервисы - обычное дело при внедрении микросервисов. Множество проектов начинаются с монолита, а потом распиливаются на отдельные модули. С другой стороны при желании можно начинать и сразу с микросервисной архитектуры.

Эта глава рассматривает возможные причины перехода к микросервисной архитектуре, а так же типовые стратегии такой миграции.

## Причины для миграции
Микросервисы предлагают свежий старт. Код легаси приложения можно не использовать, а построить рядом микросервис с нуля. Типичной причиной такой миграции является сам факт наличия легаси кода, устаревшего решения, которое тяжело поддерживать.

Сюда же можно отнести ряд уже известных причин, относящихся к микросервисам в принципе:
- Устойчивость к сбоям
- Возможность независимого масштабирования отдельных сервисов

Можно еще упомянуть ускорение разработки. Когда большая команда пилит большой монолит, это требует от них больших усилий по координации своей работы - это может сильно замедлять разработку. Опять же релизить большой монолит тоже долго и больно.

## Типичные стратегии миграции
Часто бывает понятно, что хочется видеть в результате миграции, но непонятно с чего начать и какие шаги предпринять после для достижения этого результата. Единого подхода тут нет, но можно рассмотреть типовые сценарии.

Типовые потребности миграции в микросервисы это:
- Нецеленность на повышение скорости разработки
- Необходимость получить преимущество от перехода на микросервисы так быстро как только возможно.

Стратегия описанная тут основана на постепенном извлечении частей приложения в отдельные микросервисы.

### Отдавайте предпочтение асинхронной коммуникации
Интеграция с легаси системой должна происходить через асинхронную коммуникацию. Устаревшая система должна генерировать события, а микросервис должен на них реагировать. Это позволяет отделить логику работы нового микросервиса от устаревшего кода, а еще новый сервис не упадет при падении монолита.

Синхронная коммуникация должна использоваться с осторожность. Она ведет к слишком сильной связи нового и старого приложений. Синхронная коммуникация нужна, если вы хотите узнавать об изменениях в разных частях системы так скоро как только возможно.

### Попробуйте интегрировать UI нового сервиса с устаревшей системой через ссылки
Особенно, если у вас веб-приложение, можно пробовать интегрировать новый сервис через интерфейс пользователя. Отдельные ссылки на сайте теперь могут вести в новый сервис, а не старую систему.

Чаще всего на входе еще стоит веб-сервер, который обрабатывает все запросы и реализует терминацию TLS/SSL трафика, а то и нормальный API-гейтвей тогда подобную интеграцию будет выполнить еще проще.

### Используйте уже существующие интерфейсы
Часто в устаревшей системе уже есть интерфейс, которым пользуются другие потребители. Будет уместно, чтобы новый микросервис реализовывал уже существующий интерфейс вместо создания нового. Это облегчит его интеграцию.

### Интегрированная аутентификация
Для систем состоящих из устаревшего монолита и сияющих микросервисов негоже заставлять пользователя аутентифицироваться отдельно в каждом из них. Архитектура должна поддерживать возможность единой аутентификации в одном месте.

### Перенос данных
Даже в случае миграции каждый микросервис должен иметь свою базу данных или хотя бы отдельную схему. Если этого не делать, изменения БД в исходном сервисе приведет к непрятным сайд-эффектам в соседнем микросервисе. Так что всегда планируйте репликацию данных. Изменения можно синхронизировать с помощью событий.

Репликация должна происходить только в одном направлении. Двунаправленная репликация чаще всего не нужна, означает плохую архитектуру и боль.

### Миграция черного ящика
Когда код исходного монолита так запутан, что разобраться в нем становится практически невозможно, бывает разумным написать новый сервис основываясь только на внешнем поведении выносимого в микросервис функционала.

### Выбор первого микросервиса для миграции
Для начала нужно проанализировать предметную модель системы и разделить ее на связанные контексты. Этого может не быть в исходной системе, но это необходимо для грамотной миграции. Аналитика может быть проведена без понимания кода, т.к. она поисывает что делает система, а не то как она это делает.

Дальше все зависит от приоритетов:
- Чтобы снизить риски, можно выбрать не самую важную часть системы. Это позволит получить опыт миграции в безопасном окружении.
- Микросервисы позволяют ускорить разработку, так что можно выбрать для миграции ту часть системы, для которой в ближайшем будущем планируются масштабные изменения.

### Экстремальная стратегия: все изменения только в микросервисах
Слышал я такое и про тестовое покрытие... Стратегия предполагает, что мы полностью блокируем изменения исходной системы, а если они все же необходимы, выносим этот функционал в микросервис и меняем его уже там.

Проблемой тут может быть отсутствие по сути плана миграции. Микросервисы будут возникать в произвольных местах, где в данный момент потребовались изменения.

### Дальнейшие действия: постепенное замещение
Исходная система может быть полностью замещена микросервисами со временем. Приоритет в замещении нужно отдавать частаям системы, которую требуют масштабных изменений. Этот паттерн называется "душитель" :).

Полный переход на микросервисы может занять много времени, однако это не является проблемой само по себе.

Миграция не должна происходить сама по себе. Если нет смыла выносить что-то в отдельный сервис не нужно делать это только ради того, чтобы завести новый микросервис. В конце концов какая-то часть устаревшей системы вполне может остаться в строю при этом сильно похудев.

# Альтернативные стратегии
Есть еще куча стратегий, которые тут не упомянуты. Вот [тут](https://speakerdeck.com/ewolff/monolith-to-microservices-a-comparison-of-strategies) есть хороший обзор различных подходов в миграции на микросервисы. А мы рассмотрим часть наиболее общих подходов ниже.

### Цель: надежность
Если изначальная цель состоит в повышении надежности, для начала можно повысить надежность взаимодействия с внешними системами или базами данных с помощью библиотек типа Hystrix или Resilence4j. После этого уже можно делить систему на микросервисы в более безопасном окружении.

Полезные паттерны для повышения устойчивости:
- Timeout для любых запросов и соединений, чтобы не ждать неопределенное время при возникновении проблем с коммуникацией.
- Circuit braker для предотвращения каскадных сбоев
- Rate limiter для ограничения нагрузки на внешние ресурсы
- Bulkhead - разнообразные пулы процессов и подключений для ограничения потребления ресурсов самой системой.

[Хороший доклад на эту тему](https://www.youtube.com/watch?v=LeXQBFw5DH8)

### Послойная миграция
Другая альтернатива - это миграция по слоям. Например сначала можно мигрировать UI, отаставшаяся часть системы так же станет отдельным микросервисом (жирным, но отдельным). Это конечно не самое оптимальное решение, но в условиях когда другие пути миграции недоступны - это хоть что-то.

### Скопировать - изменить
Система копируется целиком. В каждой из копий какая-то часть кода модифицируется, а остальная удаляется. Таким образом исходная система приобразуется в два отдельных микросервиса.

Плюс в том, что старый код продолжает работать, таким образом функциональность новой системы остается близка к исходной.

Минусы такого подхода:
- Хотя старый код и остается работать, его скорее всего трудно поддерживать, иначе и мигрировать было бы незачем..
- Схема база данных и сама БД остается неизменное. А shared database - это уже не про микросервисы.
- Структура и технологический стек остаются неизменными.

# Сборка, эксплуатация и организация
Тут обсудим сборку, эксплуатацию и организацию относящиеся к миграции легаси систем.

Просто написать новый код - недостаточно для переезда на микросервисы. Код должен быть собран в приложение и отправлен в прод. Лучше всего это делать с помощью поставленных процессов CI/CD и запуска.

Должна быть выбрана подходящая стратегия тестирования. Это подразумевает автоматическое поднятие тестового окружения и независимость тестов. Например, можно сделать сервис-заглушку симулирующий поведение легаси системы. Однако, часто поведение таких систем очень сложное и его трудно повторить.

Таким образом выделение первого микросервиса может потребовать гораздо больших усилий чем всех остальных, так оно требует параллельных действий по построению инфраструктуры.

## Сосуществование микровервисов вместе с легаси системой
В процессе миграции легаси система должна поддерживать работоспособность и продолжать релизиться. Нереально обеспечить для нее ту же скорость выкладки изменений, что и для микросервисов. Поэтому изменения затрагивающие и легаси систему и микросервис сложно реализовать.

Решение может быть найдено на архитектурном уровне. Если новый функционал реализуется только в микросервисе, легаси систему можно не релизить! Это к тому, что сервисы нужно нарезать в соответствии со связанными контекстами.

Другим решением можнт быть интеграция монолита через паттерны open host service или published language, чтобы необходимость изменений в нем свести к минимуму.

## Интеграционные тесты микросервисов вместе с монолитом
Должна быть возможность проверить работоспособность различных версий сервиса и монолита вместе. Монолит должен поддерживать несколько версий интерфейса для настоящих и будущих реализаций микросервиса - это позволит выкатывать его не боясь сломать интеграцию.

## Координация выкладки монолита и микросервиса
Можно поробовать выкладывать изменения в обоих системах одновременно - это решит проблемы совместимости, но тут есть и минусы:
- Вырастает риск поломок потому что задействуется больше движущихся частей
- Труднее делать откат
- Трудно реализовать это без простоя
- При наличии множества микросервисов это вообще нереализуемо, так как слишком много из них должны будут обновиться вместе.

## Организационные нюансы
Если цель миграции - это масштабирование разработки. Изменения в организационной структуре должны совпадать вместе с техническими изменениями. Кроме всего прочего с выделением части системы в микросервис и началом работы над ним отдельной команды, можно заняться вопросами определения макро-архитектуры.

В целом не стоит пытаться сделать все и сразу. Конечно взаимосвязь между необходимыми изменениями велика, но нужно стараться делать их последовательно - это пусть к успеху.

## Комбинирование подходов к миграции
- Типичные подходы к миграции хорошо ложаться на идею [self-containing systems (SCS)](https://scs-architecture.org/). Таким образом миграция может представлять из себя просто преобразование части системы в SCS.
- Правила аутентификации и коммуникации между монолитом и микросервисом могут лечь в основу макроархитектуры.
- Интегрированный фронтенд ожет иметь смысла для связи легаси с микросервисом.
- Асинхронное взаимодействие отлично подходит для микросервисов так как обеспечивает низкую связанность.
- Синхронное взаимодействие нужно использовать с опаской.
- Kubernetes, PaasS или Docker могут быть интересными решениями для запуска микросервисов, но если они означают внедрение новой платформы, то переезд на них может подтребовать много сопутствующих усилий, так что на первом этапе возможно стоит остановиться на классическом варианте деплоя. В то же время в будущем такие системы могут иметь огромное количество плюсов и к ним нужно стремиться.





