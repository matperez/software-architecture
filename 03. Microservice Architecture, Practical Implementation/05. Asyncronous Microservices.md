# Concept: Asyncronous Microservices
В этой главе обсудим:
- Как микросервисы могут взаимодействовать асинхронно
- Какие протоколы могут использоваться для асинхронной коммуникации
- Как связаны асинхронная коммуникация и события
- Плюс и минусы асинхронной коммуникации.

## Определение
Сервис считается асинхронным, если он:
- Не выполняет запросов к другим микросервисам в процессе обработки своего запроса
- Если и делает запросы к другим сервисам, то не дожидается их завершения

### Отсутствие коммуникации
Если сервис не общается с другими сервисами в процессе обработки запроса, значит он общается с ними в другое время. Например он может реплицировать данные других сервисов чтобы использовать их локально в момент обработки запроса.

![](attachments/Pasted%20image%2020220502132016.png)

### Не ждет ответа
Сервис отправляет запросы к другим сервисам, но не дожидается ответа. Например, сервис обрабатывающий заказ шлет запрос другому севервису, который отправляет счет, но не дожидается ответа потому что это не обязательно для обработки заказа.

![](attachments/Pasted%20image%2020220502132229.png)

## Репликация данных, связанные контексты и протоколы
Асинхронная коммуникация усложняется, когда в процессе обработки запроса участвуют данные из других сервисов.

К примеру, сервисы каталога продуктов, обработки заказа и выставления счетов треюут данные о продуктах и покупателях.

Каждый из сервисов хранит только часть информации об этих сущностях:
- Каталог дожен отображать продкты, так что у него есть картинка и описание продуктов.
- Сервис выставления счетов хранит цены и проценты налогов.

Это отвечает описанию связанного контекста: каждый связанный контекст должен хранить у себя всю информацию необходимую для его функционирования. Другие контексты не должны иметь прямой доступ к этим данным.

В плане синхронной коммуникации не так важно какой именно протокол используется, важно, что сервис дожидается ответа на каждый запрос. Таковыми могут являться REST и HTTP. В тоже время возможна реализация асинхронной коммуникации и с этими протоколами.

Асинхронную коммуникацию лучше всего реализовывать с помощью асинхронных протоколов.  При асинхронной коммуникации сервис отправляет сообщение и не ожидает ответа. Системы доставки сообщений типа Kafka идеально подходят в этом случае.

## События
В примере системы приведенной ниже асинхронная коммуникация может иметь различный вид:
- Сервис обработки заказов может уведомлять сервис выставления счетов, о том, что новый счет должен быть выставлен.
- В этом случае сервис обработки заказов явно указывает сервисы выставления счетов то ему нужно делать
- Он так же посылает сообщение сервису планирующему доставку о том, что ее нужно запланировать.

С другой стороны это взаимодействие может выглядеть иначе:
- Сервис обработки заказов сообщает, что создан новый заказ
- Сервис выставления счетов сам выставляет счет
- Сервис доставки сам планирует доставку
Каждый сервис сам решает каким образом ему реагировать на событие. Это ведет к уменьшению связности между микросервисами. Мы можем даже добавить еще один сервис о котором сервис обработки заказов ничего не знает, которые будет реагировать на его события.

![](attachments/Pasted%20image%2020220502161112.png)

### События и DDD
Этот подход нелегко реализовать. Важный вопрос, на который нужно ответить: что за данные передаются в событии?

Если данные используются для столь разных задач: выставление счетов, ведение статистики, рекомендации - событие должно содержать много данных.

Это противоречит идее DDD согласно которому каждая доменная модель валидна только в своей предметной области.

### Паттерны стратегического дизайна
Контексты выставления счетов и доставки реагируют на события происходящие в третьем контексте обработки заказов.

В DDD есть паттерн постащик/потребитель для этого. Команды двух первых контекстов могут диктовать третьему какие данные им нужны.

Тоже самое в принципе применимо и к синхронному взаимодействию.

Таким образом события могут развязать сервисы между собой, но в тоже время могут и создать скрытые зависимости. Координация взаимодействия все же необходима.

Если вы не знаете кто реагирует на то или иное событие вы больше не контролируете свою систему, не можете ее свободно менять.

### Специальные события
Одним из решений может быть разделение событий направляемых в разные контексты. Т.е. для сервиса выставления счетов мы отправляем одно событие, а для сервиса доставки другое - каждое со своим специфичным набором данных.

Это решение применимо, если потребители требуют сильно разных данных от источника.

### Публичный язык
Другим решением может быть использование единой структуры данных для всех возможных потребителей. В это случае бывает сложно определить кому что нужно, но такой вариант проще реализовать.

Это решение применимо, если требуемые данные в основном совпадают у разных потребителей.

### Минимизация данных события
Другим решением может быть минимизация данных о событии. Например в нем может содержаться только ID нового заказа. Потребители могут позже отдельно запрашивать подробности по отдельному интерфейсу.

## Event Sourcing
Архитектура основанная на событиях имеет определенные преимущества:
- Состояние сервиса может быть восстановлено переигрыванием событий
- Состояние сервиса может быть вообще воссоздано заново с другой структурой

Эти идеи лежат в основе event sourcing

![](attachments/Pasted%20image%2020220502163352.png)

- Event queue отправляет события потребителям
- События сохраняются в event store
- Обработчики событий (event handlers) обрабатывают события. Снепшот состояния может быть сохранен в базе данных.

События предметной области нужно отличать от event sourcing, у них немного разное предназначение и способ использования. Подробности можно прочитать в этой статье [https://www.innoq.com/en/blog/domain-events-versus-event-sourcing/](https://www.innoq.com/en/blog/domain-events-versus-event-sourcing/). Автор заявляет, что event sourcing определяет способ хранения информации в агрегате и потому прелагает не использовать и не выпускать события такого типа за его пределы (они релевантны только в пределах этого самого контекста). В то же время, события предметной области не зависят от пособа хранения и служат для интеграции контекстов между собой.

### Раздельные или общий event store?
Event store может быть частью мироксервиса который с его помощью сохраняет события. С другой стороны единый стор для разных типов событий может являться частью инфраструктуры.

## Несогласованность и CAP-теорема
### Устаревшие события
Если необходимо хранить старые события, их хранилище может разрастись до неудобных размеров. Если же старые события пропадут микросервис больше не сможет восстановить по оставшимся данным свое состояние.

В качестве оптимизации можно удалять устревшие события которые больше не релевантны. Например, если пользователь несколько раз сменил свой адрес, можно считать что последний из заданных является наиболее релеватным и остальные удалить.

При изменениях схемы требуется либо учить сервис уметь работать со всеми вариантами событий, либо мигрировать старые события в новый формат.

### Несогласованность
Ансинхронные коммуникации предполгают итоговую согласованность. Это неизбежно. Необходимо время, чтобы асинхронная система пришла в согласованное состояние.

### CAP-теорема
Согласно CAP-теореме у распределенных систем есть три характеристики:
- Согласованность (Consistency). Все части системы имею одинаковую информацию.
- Доступность (Availability). Части системы продолжают работать в случае сбоев других частей системы.
- Устойчивость к разделению (Partition Tolerance). Система продолжает работать в случае значимых потерь пакетов в сети.

CAP-теорема говорит, что любая рапределенная система может удовлетворять только двум критериям из трех.

На практике мы выбираем между первыми двумя: как система реагирует на запрос в случае если случается сетевой сбой.

### Компромисы CAP
Конечно можно реализовать некоторые компромисы. Например, рассмотрим систему с 5 репликами:
- При записи каждая реплика подтверждает, что запись завершилась успешно
- При чтении можно запросить данные сразу у нескольких реплик и взять самый новый вариант ответа
Такая система из 5 реплик в которой можно прочитать информацию только с одной реплики и только от одной из них требует подтверждение записи фокусируется на доступности. Целых четыре реплики может упасть без падения всей системы.

В тоже время она не гарантирует строгой согласованности. Дата может быть записана только в одну реплику и из-за сетевого сбоя или недостаточного времени для завершения репликации с другой реплики может прочитано устаревшее состояние.

Либо мы можем ждать потверждения от трех реплик и читать тоже из трех реплик из пяти. Это снизит вероятность возникновения ошибок записи или чтения неактуальных даных.

### CAP, события и репликация данных
CAP-теорема рассматривает хранилища данных как NoSQL базы данных которые достигают производительности и доступности через репликацию.

В принципе событие можно рассматривать как репликацию между несколькими микросервисами, но в противовес полной репликации данных между нодами NoSQL базы, каждый микросервис сам решает как именно ему реагировать на событие.

Микросервисы, которые полагаются на асинхронную коммуникацию, соответствуют определению AP системы. CAP-теорема говорит, что единственной альтернативой может быть только CP-система. Например она может сохранять данные в центральном хранилище доступном для всех микросервисов. При недоступности этого хранилища вся система встанет, но в тоже время у всех микросервисов будет актуальная версия состояния.

### Допустима ли несогласованность?
Как уже говорилось несогласованность в асинхронном взаимодействии неизбежна, если только вы не готовы пожертвовать доступностью.

Поэтому важно знать требования по согласованности. Пользователи хотят надежных систем. Несогласованность вроде как противоречит этому. Поэтому важно знать что произойдет при временной несогласованности данных и будет ли это вообще являться проблемой. Если же несогласованность не допустима вовсе, то коммуникации должны быть только синхронными.

### Борьба с несогласованностью
В простейшем случае несогласованность исчезает как только все события достигают адресатов. Но могут быть и исключения:
- После регистрации пользователь получает начальный кредитный баланс
- Сервис кредитного баланса получает собитие инициализации баланса, но еще не получил события регистрации пользователя.
- Сервис не может выдать кредит пока пользователь не зарегистрируется
- Если событие регистрации таки придет позже, инициализация баланса будет проведена снова.
Этот кейс решается гарантированным порядком поступления событий. К соэалению многие решения не могут его гарантировать.

 Event Sourcing тоже можно помочь. Он позволяет пересоздавать стейт из истории событий, если он вдруг собрался криво.

Можно адаптировать доменную логику так, чтобы она поддерживала обработку кривых, недозаполненных данных, однако в этом слуае она может стать очень сложной, непонятной, неподдерживаемой так что этот вариант лучше избегать всеми способами.

### Гарантированная доставка
В ансинхронных системах можно гарантировать доставку сообщений, если правильно все организовать.

Продюсер должен добиться подвреждения приема сообщения от очереди сообщений, а та в свою очередь должна добиться подтвреждения получения события от подписчика. При этом если подписчик так и не получит сообщения из очереди, продюсер все равно будет считать, что успешно его отправил. Сложно гарантировать доставку, если подписчик анонимен так как не у кого спросить.

### Идемпотентность
Если сообщение не получено потребителем, оно будет отправлено повторно. Если подписчик не может потвердить получение события, например, из-за сбоя обработки. Возможно, он получит его повторно. Такая стратегия доставки называется *At least once delivery*.

Поэтому важно проектировать системы так, чтобы обработка событий была идемпотентной.

Например с сервисом выставления счетов:
- Сервис должен начала проверить нет ли уже готового счета
- Если да, сообщение о создании счета не должно обрабатываться повторно

Несмотря на идемпотентность, порядо событий все еще может быть важен.

### Тестирование
Для тестирования асинхронных микросервисов, которые реагируют на события можно поробовать отправлять события и проверять правильно ли отреагировал сервис, однако, не всегда понятно достаточно ли времени прошло и успел ли сервис обработать сообщение. Тест может проверять отправил ли сервис корректное сообщение в ответ.



