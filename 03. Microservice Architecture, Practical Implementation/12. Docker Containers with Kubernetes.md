# Recipe: Docker Containers with Kubernetes
[Kubernetes](https://kubernetes.io/) получает все большую и большую значимость в качестве среды для разработки и эксплуатации микросервисов.

Существует множество вариантов запуска Kubernetes:
- [Minikube](https://github.com/kubernetes/minikube) для запуска на локальных машинах разработчиков
- [kops](https://github.com/kubernetes/kops) автоматизирует установку Kubernetes в разных окружениямх типа AWS (Amazon Web Services)
- [Amazon Elastic Container Service for Kubernetes (Amazon EKS)](https://aws.amazon.com/eks/) предоставляет кластер Kubernetes на AWS.
- [Google Container Engine](https://cloud.google.com/container-engine) делает тоже самое в Google Cloud
- Miscrosoft Azure предоставляет [Azure Container Service](https://azure.microsoft.com/en-us/services/container-service/)
- IBM Bluemix предоставляет [IBM Bluemix Container Service](https://console.ng.bluemix.net/docs/containers/container_index.html)

## Принципы Kubernetes
Плюсом к идеям реализуемым в Docker, Kubernetes добавляет собственные концепции:

**Nodes** - это сервера на которых запущен Kubernetes, они объединяются в кластеры.

**Pods** - это один или несколько Docker контейнеров, которые вместе реализуют тот или иной сервис. Docker контейнеры в поде могут совместно использовать Docker volumes и эффективно обмениваться данными.

Контейнеры, которые принадлежат одному поду запускаются на одной ноде. Для масштабирования но большее количество нод, требуется запуск дополнительных подов.

![](attachments/Pasted%20image%2020220508142849.png)

**Replica set** обеспечивает запуск необходимого количества запущенных подов. Это позволяет распределять нагрузку на несколько подов а так же обеспечивает отказойстойчивость, так как если Pod упадет, он автоматически будет запущен повторно.

**Deployment** генерирует replica set и предоставляет необходимые Docker образы.

**Services** позволяют получать доступ к подам. Сервисы регистрируются с собственным именем в DNS и получают выделенные IP через который они становятся доступными в кластере. Также они обеспечивают машрутизацию запросов извне.

Kubernetes является **декларативным** - это значит, что конфигурация определяет желаемое состояние. Kubernetes сам обеспечивает реализацию желаемого состояния.

Поснольку Kubernetes построен поверх контейнеров, он не вносит никаких зависимостей в систему на уровне кода.

## Пример
Пример, приведенный в этой главе аналогичен тем, что приводились ранее
- Сервис Catalog упраляет информацией о товарах. Он предоставляет UI и REST интерфейс
- Сервис Customer хранит информацию и покупателях, он также предоставляет UI и REST интерфейс
- Сервис Order принимает заказы. Он предоставляет UI и REST и обращает с другими сервисами через REST.
- Веб-сервер Apache обеспечивает доступ к отдельным микросервисам.

![](attachments/Pasted%20image%2020220508144315.png)

Микросервисы доступны снаружи через порт ноды. На каждой из нод кластера запрос к конкретному порту перенаправляется на конкретный сервис. Порты назначаются автоматически.

Балансировщик нагрузки реализован сервисом Kubernetes для распределения нагрузки между нодами.

Исходный код доступен по адресу [https://github.com/ewolff/microservice-kubernetes](https://github.com/ewolff/microservice-kubernetes).

### Реализация микросерисов в Kubernetes
Картинка ниже описывает взаимодействие компонентов Kubernetes в микросервисах:
- Деплоймент создает replica set с помощью Docker образов
- Replica set стартует несколько подов
- Поды в примере содержат только один контейнер в котором запущен сервис.

![](attachments/Pasted%20image%2020220508144704.png)

### Service discovery
Service обеспечивает доступ к replica set. 
- Он предоставляет IP-адрес и запись в DNS
- Другие поды обращаются к сервису получая IP адрес в DNS
- Таким образом Kubernetes реализует обнаружение сервисов через DNS

Дополнительно к DNS микросервисы могут полуать IP адреса других микросервисов через переменные окружения.

### Отказоустойчивость
За отказоустойчивость отвечает replicat set, который поднимает упавшие поды и следит, чтобы их количество оставалось неизменным.

### Балансировка нагрузки
Replica set запускает несколько одинаковых подов сразу. Все поды могут быть доступны через IP адрес предоставляемый сервисом. Запрос приходит этот IP адрес и распределяется по всем сервисам. **Kubernetes  не предоставляет балансировку запросов на уровне DNS**

### Маршрутизация с веб-сервером Apache
В данном примере Apache сконфигурирован как реверсивный прокси. Он перенаправляет внешие запросу к нужным микросервисам. Балансировка, обнаружение сервисов и отказойстойчивость реализуются Kubernetes.

### Машрутизация с помощью node port
Сервисы так же предлагаю решение для маршрутизации (внешнего доступа к микросервисам):
- Сервис генерирует node port
- Через этот порт сервис доступен на любой ноде кластера
- Если под который реализует этот серсив недоступен на ноде на с которой к нему происходит обращение, Kubernetes перенаправляет запрос на ту ноду, на которой соответствующий под запущен.

Таким образом внешний балансировщик нагрузки может распределять нагрузку по нодам в кластере.

Запросы просто распределяютяс по разным node port. Сервис который используется для этого должен иметь тип NodePort.

![](attachments/Pasted%20image%2020220508151506.png)

### Маршрутизация с помощью балансировщика нагрузки
Kubernetes может создавать балансировщики нагрузки внутри окружения. В AWS роль балансировщика выполняет ELB (Elastic Service Balancer). Для этого используются сервисы типа LoadBalancer.

![](attachments/Pasted%20image%2020220508151658.png)

Сервисы в данном примере имеют тип LoadBalancer, однако, когда они запускаются в Minikube они обрабатываются как сервисы типа NodePort, т.к. Minikube не умеет создавать сервисы такого типа.

###  Маршрутизация с помощью Ingress
Kubernetes предоставляет расширение называемое Ingress, которое может конфигурировать и зименять доступ к сервисам из Interner.

Ingress так же может:
- Балансировать нагрузку
- Терминировать SSL
- Рализовывать виртуальные хосты

Это поведение реализуется Ingress Controller.

В нашем примере запросы машрутизируются веб-сервером Apache, однако ту же работу может выполнять Kubernetes Ingress.

Настройки Ingress выполняются YAML-манифестами как и все остально в Kubernetes.

## Дополнительные функции Kubernetes
### Мониторинг здоровья и готовности
Kubernetes распознает сбои подов через [Liveness Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/). Для определения того может ли контейнер принимать запросы существует [Readiness Probe](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#define-readiness-probes).

Если приложение загружено тяжелым запросом или еще не стартовало полностью, оно может сообщить об этом через свою Readiness Probe.

В отличие от Liveness Probe, если приложение провалит свою пробу готовности - это не приведет к перезапуску контейнера.

### Конфигурация
Конфигурация приложений возможна с помощью [ConfigMaps](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/). Настройки передаются через переменные окружения.

### Разделение окружений через неймспейсы
Окружения Kubernetes могут разделяться с помощью [Namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/). Нейспейсы - это механизм реализации виртуального кластера. Они позволяют нескольким окружениям существовать в одном и том же кластере одновременно.

Например можно отделять дев окружение от прода или инфраструктуру от самого приложения.

## Приложения с состоянием
### Persistent volumes и statful set
Kubernetes умеет работать с приложениями, которым нужно хранить состояние. Если приложению требуется сохранять свое состояние между перезапусками это требует достаности Docker volume на всех нодах, на которых запущено приложение.

Kubernetes предоставляет [persistent volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/) и [stateful sets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-storage) для решения подобных проблем.

## Операторы
 [Операторы](https://coreos.com/operators) позволяют расширять функциональность Kubenetes. Например, автоматически деплоить приложения вместе с состоянием.

Например, [Prometheus operator](https://github.com/coreos/prometheus-operator) устанавливает мониторинг Prometheus в кластер и  добавляет новые ресурсы типа Prometeus, ServiceMonitor и AlterManager.

### Пакетные менеджеры
Пакетные менеджеры типа [Helm](https://helm.sh/) позволяют устанавливать сложные конфигурации приложений меньшим количеством команд. Манифесты генерируются из шаблонов.

