# Concept: Synchronous Microservices
Синхронное взаимодействие это также один из вариантов взаимодействия микросервисов.

Микросервис взаимодействует синхронно, если он выполняет запросы к другим микросервисам пока обрабатывает свой запрос и дожидается их ответа.

Пример такого взаимодействия приведен на картинке

![](attachments/Pasted%20image%2020220503162733.png)

Синхронные протоколы коммуникации подразумевают, что запрос возвращает некий результат. Например протокол HTTP возвращает данные страницы в ответ на запрос типа GET.

Пример системы использующей синхронное взаимодействие:

![](attachments/Pasted%20image%2020220503163008.png)

Системы основанные исключительно на синхронном взаимодействии обладают строгой согласованность.

В тоже время есть и недостатки:
- Централизованное хранение информации может быть проблемой, так как разным частям системы могут требоваться данные в разном объеме и разной формы.
- Большая часть юзкейсов затрагиваю обращения ко многим сервисам, что делает взаимодействие сложным.
- Сбой одного из сервисов скорее всего приведет к сбою всей системы.
- Необходимость ожидания ответа может негативно сказаться на производительности.

### Связанный контекст
В принципе возможно, чтобы связанный котексты взаимдействовали между собой синхронно, но обычно они взаимодействуют путем обмена событиями - это довольно легко реализуемо при асинхронном взаимодействии и может быть сложным при синхронном.

###  Тесты
Для независимости разработки тесты каждого микросервиса должны быть независимы на столько, на сколько это возможно и количество интеграционных тестов должно быть сведено к минимуму.

Для тестов синхронного взаимодействия требуется доступность всех участников взаимодействия, что может быть сложно создать корректое окружение для тестирования.

Альтернаивой может быть использование заглушек, которые симулирует поведение других микросервисов.

Так же интересным решением может быть тестирование сервисов со стороны потребителей ([consumer-driven contract tests](https://martinfowler.com/articles/consumerDrivenContracts.html)) В этом случае клиент тестирует сервис на соответствие контракту. Если сервис отвечает как-то не так, значит команда сервиса внесла в него несовместимые изменения.

Такие тесты можно писать например на JUnit. Тесты подобного типа нужно согласовать на макроуровне, их должны соблюдать все команды. Язык написания тестов не обязательно должен совпадать с языком написания микросервисов.

Примером фреймворка реализующим такой вариант тестирования является [Pact](https://pact.io/). Он позволяет писать тесты REST интерфейсов. Результатом его работы являются JSON-файлы содержащие REST-запросы и ожидаемые ответы.

###  Преимущества
На синхронная коммуникация - это относительно часто используемый подход. Многие хорошо известные примеры микросервисных архитектур используют этот коцепт.

Он имеет следующием преимущества:
- Меньше проблем с согласованностью
- Синхронные коммуникации ествественны для продкутов предоставляющих API для внешних клиентов или мобильных приложений
- На такую архитектуру может быть проще мигрировать
- Вызовы методов, процедур, функций в программах обычно синхронны, разработчикам привычна такая модель.

Минусы:
- Низкая производительность
- Каскадные сбои
- Высокий уровень связности

### Технические решения
Для реализации системы их синхронных микросервисов необходимо применение некоторых технических решений. Давайте их обсудим.

#### Обнаружение сервисов
Мироксервисам нужно знать как коммуницировать с другими сервисами. Обычно для этого нужно знать IP-адрес и порт целевого сервиса. Эту работу выполняет service discovery.

Обнаружение сервисов должено быть динамическим, т.к. микросервисы могут масштабироваться и умирать.

Простейшим вариантов обраружения сервисов является DNS.

#### Устойчивость к сбоям
Когда коммуникации синхронны микросервисы должны быть готовы к сбоям других сервисов, что бы не падать вслед за ними. Иначе могут происходить каскадные сбои.

#### Балансировка нагрузки
Каждый микросервис должен масштабироваться независимо от отстальных. Нагрузка должна балансироваться между всеми инстансами сервиса. Причем это должно выполняться не только для внешних, но и для внутренних клиентов сервиса. Таким образом балансировка нагрузки должна быть у каждого отдельного микросервиса.

#### Маршрутизация
Запросы должны достигать нужных микросервисов, т.е. нужна машрутизация.

Для сложных API может потребоваться сложная маршрутизации запросов к микросервисам. В этом случае может помочь API gateway:
- Они умеют аутентифицировать пользователей
- Могут выполнять троттлинг запросво для снижения нагрузки
- Логировать запросы, инструментировать, документировать.


