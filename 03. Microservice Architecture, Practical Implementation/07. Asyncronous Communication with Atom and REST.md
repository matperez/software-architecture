# Recipe: Asyncronous Communication with Atom and REST

В этой главе рассмотрим коммуникацию основанную на формате данных Atom. Пример системы, которая взаимодействует с помощью Atom можно найти тут [https://github.com/ewolff/microservice-atom](https://github.com/ewolff/microservice-atom).

[Atom](https://validator.w3.org/feed/docs/atom.html) - это формат данных созданный для реализации подписки читателей на блоги. Документ Atom содержит записи блога в хронологическом порядке. Из-за своей гибкости Atom подходит для разные типов данных. К примеру севрис заказов из примера может публиковать с его помощью события изменения данных о заказах.

### Типы MIME 
Основанная на HTTP коммуникация описывает формат данных через типы MIME (Multipurpose Internet Mail Extension). Тип MIME для Atom это `application/atom+xml`.

### Feed
Данные Atom отдаются в виде ленты:
```xml
<?xml version="1.0" encoding="UTF 8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Order</title>
	<link rel="self" href="http://localhost:8080/feed" />
	<author>
	<name>Big Money Online Commerce Inc.</name></author>
	<subtitle>List of all orders</subtitle>
	<id>tag:ewolff.com/microservice-atom/order</id>
	<updated>2017 04 20T15:28:50Z</updated>
	<entry>
	...
	</entry>
</feed>
```

### Entry
Отдельная запись в ленте выглядит следующим образом:
```xml
<entry>
	<title>Order 1</title>
	<id>tag:ewolff.com/microservice-atom/order/1</id>
	<updated>2017 04 20T15:27:58Z</updated>
	<content type="application/json"
	src="http://localhost:8080/order/1" />
	<summary>This is the order 1</summary>
</entry>
```

### Polling of Atom feeds
Асинхронная коммуникация через ATOM подразумевает, что клиент будет переодическ запрашивать данные с сервера и обрабатывать новые появившиеся в ответе записи. Это называется полинг.

Новые данные можно пытаться определить по полю `updated` , но это был бы очень долгий процесс, потому что каждый раз нужно генерировать и читать полную ленту записей. 

В дополнению к этому можно изначально отдавать с сервера тольк обновившиеся записи. Это легко реализуемой с помощью кеширования на уровне HTTP. Для этого существует заголовоки Last-Modified и If-Modified-Last. Также можно воспользоваться механизмом кеширования через Etag.

### Статическая лента Atom
Можно сгенерировать ленту один раз, сохранить ее в готовом виде и раздавать как статический ресурс. Это может сэкономить много ресурсов серверу.

### Фильтрация и пагинация
Фильтрацию и пагинацию можно реализовать через параметры HTTP запроса.

### Гарантированная доставка
Atom через HTTP не может гарантировать доставку данных. Сервер только предоставляет данные, а запросит ли их клиент он не может гарантировать.

### Старые сообщения
В прицнипе Atom спокойно может хранить и отдавать все имеющиеся сообщения о заказе, так что он подходит для реализации механизма Event Sourcing.

## Пример реализации
На картинке можно посмотреть примерную структуру системы построенной на взаимодействии через Atom.

![](attachments/Pasted%20image%2020220503161751.png)

- Apache HTTPd распраделяет запросы между микросервисами
- Сервис Order предоставляет Atom ленту событий связанные с заказами
- Сервисы Shipping и Invoicing получают информацию из ленты Atom.
- Все микросервисы используют одну и ту же базу Postgres, но у них изолированные схемы.

### Обработка данных и масштабирование
Если увеличить число реплик сервисом Shipping или Invoicing, все реплики будут читать одну и ту же ленту и может возникнуть кофликт, если вруг несколько инстансов начнут создавать счета по одному и тому же заказу. Чтобы этого избежать инстансы должны использовать транзакции при работе с БД.

### Atom не может отправить данные конкретному реципиенту
Atom не может отправить данные конкретному реципиенту. Таким образом сами подписчики должны заботиться об избежании множественной обработки одних и тех же событий.
