# Self-contained Systems
SCS это тип микросервисов, который определяет элементы макроархитектуры. Они не определяют макроархитектуру полностью. Например часть связанная с эксплуатацией отсутствует полностью.

SCS представляет из себя микросервис, в котором содержится все для реализации части доменной логики (связанного контекста). Таким образом он содержит логику, данные и UI (микросервисы не обязательно содержат UI).

SCS - это набор практик реализации микросервисов, которые доказали свою эффективность в разных проектах. В тоже время - это не не золотая пуля, не решение для каждой ситуации. Поэтому важно понимать принципы которые лежат в основе SCS.

### Определение
- Каждая SCS - это автономное приложение содержащее логику, данные и UI.
- Общего UI не существует. SCS могу содержать html-ссылки на другие SCS, но каждый отдельный элемент UI принадлежит конкретной SCS, нет отдельных сервисов генерирующих общий UI.
- SCS _могут_ иметь API, через которые, к примеру, мобильные клиенты или другие системы могут переиспользовать логику реализуемую SCS.

Соблюдение этих правил гарантирует, что в слуае сбоев изменения коснутся только одного конкретного SCS и их фикс ограничится деплоем одного сервиса. В противном случае придется делать согласованный деплой нескольких сервисов, что сделать куда сложнее.

### Правила коммуникации
Коммуникация между SCS должна следовать следующим правилам:
- Интеграция через UI идеальна для интеграции, так как она обеспечивает минимальную связанность. Даже если в данном SCS UI изменится, это не затронет представление и логику других SCS.
- Другим правилом является асинхронная комуникация. Это обеспечивает надежность, т.к. при падении какого-нибудь из SCS другие не упадут и могу спокойно дождаться момента когда упавший SCS поднимется.
- Синхронное взаимодействие тоже возможно. В этом случае нужно предусмотреть инструменты для борьбы с возможными сбоями или слишком долгими ответами отдельных сервисов.

### Базы данных
Правила предполагают, что SCS должны реплицировать данные сторонних систем, для их использования. SCS должны иметь собственную базу данных и взаимодействовать с другими SCS асинхронно. Если SCS потребуется запросить у кого-то данные для обработки запроса, это будет означать синхронное взаимодействие, так что все данные должны быть доступны еще до начала обработки запроса.

Из этого следует, что SCS не всегда согласованны. Если от системы требуется строгая согласованность, SCS должны использовать синхронное взаимодействие и получать нужные данные от других  SCS напрямую.

### Правила организации
SCS должа принадлежать одной команде. Команда может владеть и несколькими SCS. Команда не обязательно должна выполнять все изменения в SCS, но как минимум делать ревью и принимать или отвергать предлагаемые изменения. В целом не желательно чтобы в одну SCS вносили изменения несколько команд.

Таким образом использование SCS дает следующие организационные преимущества:
- Минимальная необходимость в межкомандной синхронизации. Команды могут работать параллельно и независимо.
- Требования могут быть реализованы в рамках одной SCS, одной командой.

### Минимизация общей базы
Поскольку SCS целятся в высокую независимость разработки, общий базис должн быть сведен к минимуму.

Нужно избегать общей бизнес логики. Общая бизнес логика приводит к излишней связанности между разными SCS. В то же время один SCS может использовать логику другого SCS через явно предоставляемый интерфейс.

Нужно избегать общей инфраструктуры. SCS не должны иметь общих баз данных.  В тоже время, если это требует слишком многих усилий, допустимо шарить базу данных, но при этом SCS должны иметь отдельные назависимые схемы данных в этой БД и полностью, и единалично управлять ими.

## Пример
![](attachments/Pasted%20image%2020220501221505.png)
Пример выше показывает e-commerce систему разделенную на контексты поиска, оформления заказа, оплаты и доставки. Он может быть реализовать с помощью отдельных SCS.

### Коммуникация
Пользователь отправляет HTTP-запрос в систему. Запрос обычно обрабатывается какой-то одной SCS т.к. все необходимая логика доступна внутри нее.

Это хорошо для производительности и надежности. Сбой в отдельной SCS не приведет к падению всей системы. К тому же, т.к. данные уже реплицированы, можно избежать долгих и ненадежных сетевых запросов.

Конечно же SCS должны коммуницировать между собой ведь они являются частью единой системы. Например жизненный цикл заказа предполагает следующие шаги:
- Поиск товара
- Добавление его в корзину
- Оплата заказов в корзине
- Доставка и отслеживание доставки

При переходе между шагами SCS должны обмениваться данными между собой. Это может быть сделано асинхронно. Нет нужды иметь обновленные данные в другой SCS пока не придет новый HTTP запрос, так что временная несогласованность уместна.

## SCS и Микросервисы
SCS являют собой независимо поставляемые модули, таким образом они удовлетворяют определению микросервисов.

### Один SCS может быть реализован через несколько микросервисов
Один SCS может быть реализован через несколько микросервисов. Например, если какая-то часть процесса оплаты из примера выше вызывает повышенную нагрузку, весь домен может быть разделен на несколько микросервисов, которые могут быть масштабированы независимо.

Другой причиной для выделения микросервиса могут быть соображения безопасности. Например, процесс расчета стоимости можно реализовать где-то отдельно предусмотрев дополнительные ограничения.

В случае такого разделения разные команды могут работать над микросервисами реализующими один SCS.

![](attachments/Pasted%20image%2020220501223410.png)

Итого:
- Микросервисы обычно меньше SCS
- SCS целятся в снижение связанности
- SCS должны иметь собственный UI
- SCS рекомендуют интеграцию через UI или асинхронную коммуникацию. Асинхронная коммуникация возможна, но не поощеряется.

## Сложности
SCS определяет более строгие правила, чем микросервисы, так что их использование имеет больше ограничений.

### Только веб-приложения
SCS подходят только для веб-приложений, так что в случаях когда UI отсутствует они не подходят. В то же время отдельные аспекты SCS типа разделения предметной области и асинхронной коммуникации полезны в любом случае.

В приципе, за UI можно принять и публичный API. В этом случае все правила SCS будут применимы.

### Single page app (SPA)
SPA - это обычно приложения реализованные на JavaScript реализующие сложную логику. Такими являются, например, Google Maps или Gmail - SPA в этом случае подходят идеально.

У них конечно есть и минусы:
- Очень часто в таких приложениях бизнес логика протекает в UI
- Время загрузки большого SPA приложения увеличивается

SPA реализует цельную системы, а значит предполагает существование общего UI, что запрещено SCS. Можно попробовать создавать SPA на каждую отдельную SCS.

Альтернативой использованию SCS в этом случае является архитектура ROCA, которую гораздо проще реализовать в рамках SPA.

### Мобильные приложения
SCS не подходят для мобильных приложений в качестве бекенда, так как они содержат отдельный UI, что противоречит принципам SCS.

Можно рассмотреть следующие альтернативы:
- веб приложение
- веб приложение с фреймворком типа cordova или react native
- нативное преложение с бекендом SCS реализующим REST интерфейс

### Единый внешний вид
Единый внешний вид может быть реализован только макроархитектурным решением. Это так же применимо и к SCS.

*Важно*: если разовые изменения чаще всего затрагивают только UI или только бизнес логику, возможно, стоит разделить приложение по слоям, а не на SCS.





