# Concept: Fronend Integration
Эта глава описывает каким образом сервисы могут интегрироваться на уровне веб-фронтенда.

## Фронтенд: монолитный или модульный?

### Монолитный фронтенд и бекенд
Монолитные бекенд и фронтенд вполне себе может быть решением удовлетворяющим требованиям.

![](attachments/Pasted%20image%2020220502004332.png)

### Модульно разрабатываемый фронтенд
Фронтенд при том, что разрабатывается отдельными модулями вполне может деплоиться как монолитное приложение. К сожалению это не защищает от протекания логики одних модулей в другие со временем.

В любом случае каждый модуль в монолитном фронтенде может быть сопоставлен отдельному микросервису на бекенде, для разделения и параллелизации разработки.

![](attachments/Pasted%20image%2020220502004612.png)

### Аргументы за монолитный фроентенд
Монолитный фронт может быть уместен в некоторых ситуациях.

* Нативные мобильные приложения и приложения с богатой логикой на клиенте. Нативные мобильные и гибридные приложения - это всегда монолитный фронтенд.
* SPA тоже должны деплоиться как целое. Есть теоретическая возможность разделить SPA на отдельные составляющие, но на практике они скорее всего не реализуются.
* Существование выделенной команды полностью специализирующейся на фронтенд-разработке.
* Миграция существующей системы может быть проще, если монолитный фронтенд останется неизменным.

### Модульный фронтенд
Альтернативой монолиту может быть полностью модульный фронтенд.
![](attachments/Pasted%20image%2020220502005412.png)

Такое разделение имеет некоторые плюсы:
- Микросервисы становятя SCS и реализуют всю доменную логику.
- Изменения в предметной логике затрагивают только один микросервис. Не нужно тратиться на синхронизацию множественных деплоев.

Чтобы объединить отдельные модули фронтенда в единую систему, их нужно как-то интегрировать между собой. Это возможно только при выбранном едином подходе к интеграции микро-фронтендов.

## Варианты итеграции
### Ссылки
Самый простой вариант интеграции - это взаимные ссылки. Один фронтенд содержит ссылку на другой. По сути так работает весь веб.

![](attachments/Pasted%20image%2020220502005910.png)

### Редиректы
Например на редиректах основана работа OAuth2:
- Вебсайт публикует ссылку на провайдера OAuth2 типа Facebook или Google
- Пользователь вводит свой пароль и подтверждает, что данный веб-сайт имеет право на доступ к его информации
- Пользователь редиректится назад на исходный сайт при этом исходный сайт получает информацию о пользователе.
![](attachments/Pasted%20image%2020220502010126.png)

### Инклуды (Включения)
Наконец есть куча вариантов инкулудов, которые позволяют включить содержимое одного сайта в другой. Это можно сделать как на клиенте, так и на сервере. Наример ESI (Edge Site Includes) или SSI (Server Side Inclides).

## Resource-oriented Client Architecture (ROCA)
ROCA - это подход реализации веб-приложений который фокусируется на давно известных технологиях типа HTML и ведет к архитектуре которая использует выгодные аспекты модуляризации и интеграции.

### Принципы ROCA
* Приверженность принципам REST
	* Все ресурсы имеют уникальные ссылки
	* Ссылки на веб-страницы могут быть отправлены пользователю любым способом и не требуют авторизации при переходе по ним от пользователя
	* HTTP-методы используются согласно своей семантике
	* Сервер не хранит состояния
* Доступность информации. Ресурсы доступные по ссылкам могут отдавать информацию не только в виде HTML, но так же и в других требуемых форматах типа JSON или XML.
* Вся логика находится на сервере. JavaScript на клиентской стороне используется только для оптимизации пользовательского интерфейса. Доступ к системе должен быть обеспечен не только браузеру, но и другим возможным клиентам. Логика на сервере может быть еще и более секьюрным решением, так как отделные клиенты могут быть скомпроментированы.
* Аутентификация через HTTP-запросы. Аутентификация должна поисходить исключительно на основе информации, содержащейся в HTTP-запросе. Это может быть HTTP-basic, digest, клиентские сертификаты, токены или куки. В свою очередь куки не должны содержать бизнес-информации, они могут быть использованы только для:
	* Аутентификации
	* Трекинга пользователей
	* Защиты от CSRF атак
* Не должно быть сессий на стороне сервера - это противоречит идее хранения стейта исключительно на клиенте. Это условие усложняет балансировку запросов.
* Браузерные действия типа вперед, назад, обновить страницу должны продолжать работать как оно ожидается. Это кажется естественным, но у многих приложений возникают с этим сложности.
* JavaScript должен использоваться только для "шашечек". Все "ехать" должны быть реализованы на стороне сервера.

### Преимущества ROCA
* Чистая архитектура. Вся логика находится в одном месте на сервере. Изменения могут быть легко выложены с новой версией сервера
* Можно использовать все преимущества HTTP:
	* URL может быть отправлен другому пользователю
	* Можно использовать HTTP кеширование
	* Можно эффективно использовать всякие оптимизации на уровне браузеров
* Низкое потребление трафика, а не как в SPA где нужно выкачать все приложение, чтобы что-то начало отображаться.
* Высокая скорость, особенно на мобильных устройствах так как там обработка JavaScript может быть не столь быстрой как на десктопах.
* Устойчивость к сбоям и отсутствие обязательного наличичя JavaScript на клиенте.
* SEO-оптимизация. Такие системы более дружелюбны к поисковым движкам.

Несмотря на все преимущества, для сложных интерфейсов типа онлайн игр или карт может быть предпочтительннее SPA.

## Сложности
### Инфраструктура UI
Для интеграции на уровне UI требуется определенная инфраструктура типа общего CSS или JavaScript кода или серверной архитектуры для реализации SSI.

Могут потребоваться части UI, не принадлежащие никакому микросервису такие как домашняя страница или строка навигации.

Важно не выделять слишком много логики в UI инфраструктуру и не создавать через нее излишние связи между микросервисами.

### Интерфейс в интеграции фронтендов
Включения типа SSI создают более сильные связи между микросервисами чем интеграция через ссылки. Они требуют общего CSS или JavaScript.

### Кроссмодульные изменения в UI
Если изменения затрагивают в основном UI и распространяются на несколько модулей - это может быть проблемой из-за распределенной природы приложения. В то же время в правильной архитектуре UI можно менять шаг за шагом тем самым минимизируя возможные риски.

Мы предполагаем тут, что глобальный UI меняется реже, чем отдельные части бизнес-логики, так что это не сильно значимый минус.

## Преимущества интеграции фронтендов
* Низкая связность
* Логика и UI в одном микросервисе
* Свободный выбор технологий фронтенда. Это не всегда так. Какие-то способы интеграции накладывают меньше ограничений на выбор технологий отдельных сервисов, а какие-то больше.



