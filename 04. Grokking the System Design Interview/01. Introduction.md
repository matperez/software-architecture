# Введение
## Пошаговое руководство по system design итервью
### Шаг 1: Прояснить требования
Для начала стоит выяснить цели, масштаб проблемы, которую мы пытаемся решить. Поскольку на этот этап обычно отводится 35 - 40 минут на дизайн сравнительно большой и сложной системы, важно выяснить заранее на каких ее частях мы будем концентрироваться.

К примеру для системы подобной Twitter можно задать следующие вопросы:
- Будут ли пользователи сервиса иметь возможность постить твиты и подписываться на других пользователей?
- Нужна ли нам функциональность ленты новостей (твитов)?
- Мы фокусируемся только на бекенде или нам нужно разработать и фронтенд тоже?
- Будут ли пользователи иметь возможно искать твиты?
- Нужно ли нам показывать раздел актуальных новостей?
- Нужна ли возможность присылать push-уведомления для новых (важных) твитов?

Все подобные вопросы определяют как будет выглядеть итоговый дизайн.

### Шаг 2: Выполнить предварительную оценку
Прояснить масшаб системы, которую мы пытаемся задизайнить. Это будет важно когда мы сфокусируемся на масштабировании, партицировании, балансировке нагрузки и кешировании.
- Какой масштаб ожидается от системы: количество новых твитов, количество просмотров твитов, число генерируемых лент новостей и т.п.
- Сколько нам нужно дискового пространства для хранения данных? Изменится ли эта цифра, если мы дадим возможность пользователям загружать фото и видео? И 
- Какова ожидаемая нагрузка на сеть, сколько трафика нам нужно будет прокачивать? Это будет важно когда мы будем решать как управлять трафик и балансировать нагрузку на сервера.

### Шаг 3: Определить интерфейс системы
Определить какие API ожидаются от системы, выделить явно контракт взаимодействия с системой. Это поможет понять корректно ли мы поняли выявленные требования.

Например API системы типа Twitter может быть следующим:

```
postTweet(user_id, tweet_data, tweet_location, user_location, timestamp, …)  
```

```
generateTimeline(user_id, current_time, user_location, …)  
```

```
markTweetFavorite(user_id, tweet_id, timestamp, …)  
```

### Шаг 4: Определить модель данных
Определение модели данных на раннем этапе дизайна помогает прояснить как данные будут передаваться между различными частями системы. Позже это поможет прояснить нюансы партицирования и управления данными. Нужно выявить основные сущности и то как они взаимодействуют друг с другом, каким образом данные будут храниться, передаваться, шифроваться.

Пример для сервиса типа Twitter:
- **User:** UserID, Name, Email, DoB, CreationDate, LastLogin, etc.  
- **Tweet:** TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc.  
- **UserFollow:** UserID1, UserID2  
- **FavoriteTweets:** UserID, TweetID, TimeStamp

Какую базу данных мы будем использовать? Нам подойдет NoSQL решение типа Cassandra или мы должны использовать MySQL? Какое блочное хранилище мы будем использовать для фото и видео?

### Шаг 5: Дизайн в общем виде
Нарисовать диаграмму из 5 - 6 блоков описывающую ключевые компоненты нашей системы. Нужно определить достаточное число компонентов необходимых для решения нашей проблемы от начала и до конца.

Для Twitter на глобальном уровне нам потребуется несколько серверов приложений чтобы обрабатывать запросы пользователей и балансировщик нагрузки перед ними. Если мы выясним, что запросы на чтение сильно превышают число запросов на запись, мы можем захотеть использовать выделенные сервера для этих сценариев. 

На стороне бекенада нам нужна эффективная база данных для хранения всех твитов, поддерживающая большое количество чтений. А еще нужно распределеннное файловое хранилищие для хранения изображений и видео.

![](attachments/Pasted%20image%2020220509140734.png)

### Шаг 6: Уточнить дизайн
Углубиться в изучение 2 - 3 ключевых компонентов. Куда конкретно углубляться можно понять по реакции собеседующего. Нужно показать разные подходы, их плюсы и минусы, объяснить почему стоит предпочесть один подход другому. Идеального решения нет, гораздо важнее показать компромисы между возможными решениями, сохраняя в голове изначальные ограничения системы.
- Если уж мы храним большие объемы данных, должны ли мы партицировать их для хранения в нескольких базах данных? Нужно ли нам хранить всю информацию принадлежащую одному пользователю в той же БД? Какие проблемы это может создать?
- Как нам работать с популярными пользователями, которые много пишут и имеют большое число подписчиков?
- Раз уж лента пользователя содержит наиболее свежие (релевантные) твиты, стоит ли нам пытаться хранить данные так, чтобы они были оптимизированны для получения имеено самых новых твитов?
- Где и как стоит кешировать данные, чтобы поднять производительность?
- Какие компоненты нужны для лучше балансировки производительности?

### Шаг 7: Выявить и устранить узкие места
Попробовать выявить и обсудить максимальное количество узких мест и способов их устранения.
- Есть ли единые точки отказа? Как их устранить?
- Достаточная ли у нас степень репликации данных, чтобы пережить падение нескольких серверов?
- Достаточно ли у нас копий сервисов запущено, чтобы пережить отказ нескольких из них?
- Каким образом мы мониторим производительность наших сервисов? Получаем ли мы алерты, если какие-либо критические компоненты системы отказывают?

